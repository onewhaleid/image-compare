<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>image-compare</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 18px;
      }
      .row {
        display: flex;
        gap: 12px;
        align-items: flex-start;
      }
      .col {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      canvas {
        border: 1px solid #999;
      }
      #matches {
        max-width: 100%;
      }
      .controls {
        margin-bottom: 12px;
        display: flex;
        gap: 12px;
        align-items: center;
      }
      label {
        font-size: 90%;
      }
      button {
        padding: 6px 10px;
      }

      /* Drag & drop styles */
      .dropzone {
        width: 150px;
        height: 100px;
        border: 2px dashed #bbb;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #666;
        background: #fafafa;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .dropzone.dragover {
        border-color: #4a90e2;
        background: #f0f8ff;
        color: #111;
      }
      .dropzone.small {
        width: 200px;
        height: 150px;
      }
      .hidden-input {
        display: none;
      }

      /* preview canvas inside dropzone */
      .dropzone canvas {
        display: block;
        max-width: 100%;
        max-height: 100%;
      }
      .drop-instruction {
        position: absolute;
        pointer-events: none;
        text-align: center;
        width: 100%;
      }

      /* slider styling */
      .fps-control {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .fps-control input[type="range"] {
        width: 150px;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <div>
        <div><strong>Images (drop here)</strong></div>
        <div id="dropContainer" class="row"></div>
      </div>

      <!-- Keep Align button -->
      <div>
        <button id="alignBtn">Align</button>
      </div>

      <!-- FPS slider + pause/resume button -->
      <div class="fps-control">
        <label for="fpsSlider">FPS:</label>
        <input id="fpsSlider" type="range" min="1" max="30" value="2" step="1" />
        <span id="fpsValue">2 fps</span>
        <button id="pauseBtn">Play</button>
      </div>

      <!-- Per-dropzone hidden inputs are created dynamically -->
    </div>

    <!-- Removed visible source/target canvases per request.
         Only the Matches/Overlay canvas remains. -->
      <div><strong>Composite</strong></div>
    <div class="row">
      <canvas id="animation" width="800" height="300"></canvas>
    </div>

    <script
      async
      src="https://docs.opencv.org/4.x/opencv.js"
      onload="onOpenCvReady();"
    ></script>

    <script>
      let srcImg = null,
        tgtImg = null;
      
      const dropContainer = document.getElementById("dropContainer");
      const dropZones = [];
      const alignBtn = document.getElementById("alignBtn");

      // FPS controls
      const fpsSlider = document.getElementById("fpsSlider");
      const fpsValue = document.getElementById("fpsValue");
      const pauseBtn = document.getElementById("pauseBtn");

      // Dynamic dropzones: create as needed and append to container
      function createDropzone() {
        const dropElem = document.createElement("div");
        dropElem.className = "dropzone";

        const instruction = document.createElement("div");
        instruction.className = "drop-instruction";
        instruction.textContent = "Drop image or click to select";
        dropElem.appendChild(instruction);

        const canvas = document.createElement("canvas");
        canvas.className = "preview-canvas";
        dropElem.appendChild(canvas);

        const inputElem = document.createElement("input");
        inputElem.type = "file";
        inputElem.accept = "image/*";
        inputElem.className = "hidden-input";
        dropElem.appendChild(inputElem);

        dropContainer.appendChild(dropElem);
        addDnDHandlers(dropElem, inputElem, canvas);
        dropZones.push({ dropElem, inputElem, canvas });
        return { dropElem, inputElem, canvas };
      }

      function allDropzonesFilled() {
        return dropZones.length > 0 && dropZones.every(z => z.dropElem.classList.contains("filled"));
      }

      function ensureExtraSlot() {
        if (allDropzonesFilled()) {
          createDropzone();
        }
      }

      const animationCanvas = document.getElementById("animation");

      // Utility to prevent default drag behavior
      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }
      function addDnDHandlers(dropElem, inputElem, canvas) {
        ["dragenter", "dragover", "dragleave", "drop"].forEach((evt) =>
          dropElem.addEventListener(evt, preventDefaults, false)
        );
        ["dragenter", "dragover"].forEach((evt) =>
          dropElem.addEventListener(evt, () => dropElem.classList.add("dragover"))
        );
        ["dragleave", "drop"].forEach((evt) =>
          dropElem.addEventListener(evt, () => dropElem.classList.remove("dragover"))
        );

        dropElem.addEventListener(
          "drop",
          (e) => {
            const dt = e.dataTransfer;
            const file = dt && dt.files && dt.files[0];
            if (file) loadFileToCanvas(file, canvas, dropElem);
          },
          false
        );

        // click opens file dialog as fallback
        dropElem.addEventListener("click", () => inputElem.click());
        inputElem.addEventListener("change", () => {
          const file = inputElem.files && inputElem.files[0];
          if (file) loadFileToCanvas(file, canvas, dropElem);
          inputElem.value = ""; // reset
        });
      }
      
      // Initialize with two empty dropzones
      createDropzone();
      createDropzone();

      function loadFileToCanvas(file, canvas, dropElem, callback) {
        if (!file) return;
        const img = new Image();
        img.onload = () => {
          const ctx = canvas.getContext("2d");
          // choose a sensible max to avoid huge canvases
          canvas.width = Math.min(img.width, 800);
          canvas.height = Math.min(img.height, 600);
          const scale = Math.min(canvas.width / img.width, canvas.height / img.height, 1);
          const w = img.width * scale;
          const h = img.height * scale;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0, w, h);

          // remove instruction overlay if present
          const instr = dropElem.querySelector(".drop-instruction");
          if (instr) instr.remove();

          // mark as filled and ensure there is always an extra empty slot
          dropElem.classList.add("filled");
          ensureExtraSlot();

          URL.revokeObjectURL(img.src);
          callback && callback();
        };
        img.onerror = () => {
          console.error("Failed to load image file.");
        };
        img.src = URL.createObjectURL(file);
      }

      function onOpenCvReady() {
        if (typeof cv === "undefined") {
          console.error("OpenCV.js script failed to load.");
          return;
        }
        if (cv.getBuildInformation !== undefined) {
          console.log("OpenCV.js ready:", cv.getBuildInformation());
        } else {
          cv['onRuntimeInitialized'] = () => {
            console.log("OpenCV.js ready:", cv.getBuildInformation());
          };
        }
      }

      function canvasToMat(canvas) {
        const ctx = canvas.getContext("2d");
        if (canvas.width === 0 || canvas.height === 0)
          return new cv.Mat(); // empty
        let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        let mat = cv.matFromImageData(imgData);
        return mat;
      }

      function matToCanvas(mat, canvas) {
        const ctx = canvas.getContext("2d");
        const img = new ImageData(
          new Uint8ClampedArray(mat.data),
          mat.cols,
          mat.rows
        );
        canvas.width = mat.cols;
        canvas.height = mat.rows;
        ctx.putImageData(img, 0, 0);
      }

      function alignImages() {
        if (typeof cv === "undefined") {
          alert("OpenCV.js not ready");
          return;
        }
        const filled = dropZones.filter(z => z.canvas.width > 0 && z.canvas.height > 0);
        if (filled.length < 2) {
          alert("Load at least two images (fill two drop zones).");
          return;
        }

        // Reference is the first filled image; align all others to it
        const refCanvas = filled[0].canvas;
        const others = filled.slice(1).map(z => z.canvas);

        // Helper: compute warped canvas aligning srcCanvas to refCanvas
        function warpToReference(srcCanvas, refCanvas) {
          let src = canvasToMat(srcCanvas);
          let ref = canvasToMat(refCanvas);
          if (src.empty() || ref.empty()) {
            src.delete && src.delete();
            ref.delete && ref.delete();
            return null;
          }
          let graySrc = new cv.Mat(), grayRef = new cv.Mat();
          cv.cvtColor(src, graySrc, cv.COLOR_RGBA2GRAY);
          cv.cvtColor(ref, grayRef, cv.COLOR_RGBA2GRAY);
          let orb = new cv.ORB();
          let kpSrc = new cv.KeyPointVector();
          let kpRef = new cv.KeyPointVector();
          let desSrc = new cv.Mat();
          let desRef = new cv.Mat();
          orb.detectAndCompute(graySrc, new cv.Mat(), kpSrc, desSrc);
          orb.detectAndCompute(grayRef, new cv.Mat(), kpRef, desRef);

          if (desSrc.rows === 0 || desRef.rows === 0) {
            [graySrc, grayRef, orb, kpSrc, kpRef, desSrc, desRef, src, ref].forEach(x => x.delete && x.delete());
            return null;
          }

          let bf = new cv.BFMatcher(cv.NORM_HAMMING, false);
          let matches = new cv.DMatchVector();
          bf.match(desSrc, desRef, matches);
          const mArr = [];
          for (let i = 0; i < matches.size(); i++) mArr.push(matches.get(i));
          mArr.sort((a, b) => a.distance - b.distance);
          const keep = Math.min(200, Math.max(10, Math.floor(mArr.length * 0.3)));
          const goodMatches = new cv.DMatchVector();
          for (let i = 0; i < keep; i++) goodMatches.push_back(mArr[i]);
          if (goodMatches.size() < 4) {
            [graySrc, grayRef, orb, kpSrc, kpRef, desSrc, desRef, bf, matches, goodMatches, src, ref].forEach(x => x.delete && x.delete());
            return null;
          }
          let srcPts = new cv.Mat(goodMatches.size(), 1, cv.CV_32FC2);
          let dstPts = new cv.Mat(goodMatches.size(), 1, cv.CV_32FC2);
          for (let i = 0; i < goodMatches.size(); i++) {
            const m = goodMatches.get(i);
            const pS = kpSrc.get(m.queryIdx).pt;
            const pR = kpRef.get(m.trainIdx).pt;
            srcPts.floatPtr(i, 0)[0] = pS.x;
            srcPts.floatPtr(i, 0)[1] = pS.y;
            dstPts.floatPtr(i, 0)[0] = pR.x;
            dstPts.floatPtr(i, 0)[1] = pR.y;
          }
          const mask = new cv.Mat();
          const H = cv.findHomography(srcPts, dstPts, cv.RANSAC, 5, mask);
          if (H.empty()) {
            [graySrc, grayRef, orb, kpSrc, kpRef, desSrc, desRef, bf, matches, goodMatches, srcPts, dstPts, mask, src, ref].forEach(x => x.delete && x.delete());
            return null;
          }
          let warped = new cv.Mat();
          const dsize = new cv.Size(ref.cols, ref.rows);
          cv.warpPerspective(src, warped, H, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

          // Convert to canvas
          const out = document.createElement('canvas');
          matToCanvas(warped, out);

          [graySrc, grayRef, orb, desSrc, desRef, bf, matches, srcPts, dstPts, mask, H, warped].forEach(x => x.delete && x.delete());
          kpSrc.delete();
          kpRef.delete();
          src.delete();
          ref.delete();
          goodMatches.delete();
          return out;
        }

        // Build frames: first the reference, then each warped to reference (skip nulls)
        const frames = [refCanvas];
        for (const c of others) {
          const warpedCanvas = warpToReference(c, refCanvas);
          if (warpedCanvas) frames.push(warpedCanvas);
        }

        // If only reference, nothing to animate
        if (frames.length < 2) {
          const ctx = animationCanvas.getContext('2d');
          animationCanvas.width = refCanvas.width;
          animationCanvas.height = refCanvas.height;
          ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
          ctx.drawImage(refCanvas, 0, 0);
          return;
        }

        // Start slideshow across all frames
        startSlideshowFromCanvases(frames, Number(fpsSlider.value)).catch(e => console.error(e));
      }

      alignBtn.addEventListener("click", alignImages);

      // Toggle state object used to manage animation interval/bitmaps/fps/pause
      let _toggleState = null;
      function stopToggle() {
        if (!_toggleState) return;
        try {
          if (_toggleState.timer) clearInterval(_toggleState.timer);
          if (_toggleState.bitmaps)
            _toggleState.bitmaps.forEach((b) => b && b.close());
        } catch (e) {
          console.error("Error stopping toggle:", e);
        }
        _toggleState = null;
        pauseBtn.textContent = "Pause";
      }

      async function startSlideshowFromCanvases(canvases, fps = 2) {
        stopToggle();
        try {
          const bitmaps = await Promise.all(canvases.map(c => createImageBitmap(c)));
          const ctx = animationCanvas.getContext("2d");
          const maxW = Math.max(...bitmaps.map(b => b.width));
          const maxH = Math.max(...bitmaps.map(b => b.height));
          animationCanvas.width = maxW;
          animationCanvas.height = maxH;

          // initialize toggle state
          _toggleState = {
            bitmaps,
            ctx,
            fps: Math.max(1, Math.floor(fps)),
            paused: false,
            frameIndex: 0,
            timer: null,
          };

          function drawOnce() {
            if (!_toggleState) return;
            const { bitmaps } = _toggleState;
            if (!bitmaps || bitmaps.length === 0) return;
            _toggleState.ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
            const bmp = bitmaps[_toggleState.frameIndex % bitmaps.length];
            _toggleState.ctx.drawImage(bmp, 0, 0);
            _toggleState.frameIndex = (_toggleState.frameIndex + 1) % bitmaps.length;
          }

          function setTimer() {
            if (!_toggleState) return;
            if (_toggleState.timer) clearInterval(_toggleState.timer);
            const period = 1000 / Math.max(1, _toggleState.fps);
            _toggleState.timer = setInterval(() => {
              drawOnce();
            }, period);
          }

          // draw initial frame and start interval
          drawOnce();
          setTimer();
        } catch (e) {
          console.error("Failed to start toggle:", e);
        }
      }

      // update fps display and, if running, update the running timer
      function updateFpsDisplay(val) {
        fpsValue.textContent = val + " fps";
      }

      function updateRunningFps(newFps) {
        if (!_toggleState) return;
        _toggleState.fps = Math.max(1, Math.floor(newFps));
        if (_toggleState.paused) return;
        // recreate interval preserving state
        if (_toggleState.timer) clearInterval(_toggleState.timer);
        const period = 1000 / _toggleState.fps;
        _toggleState.timer = setInterval(() => {
          if (!_toggleState) return;
          const { bitmaps } = _toggleState;
          if (!bitmaps || bitmaps.length === 0) return;
          _toggleState.ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
          const bmp = bitmaps[_toggleState.frameIndex % bitmaps.length];
          _toggleState.ctx.drawImage(bmp, 0, 0);
          _toggleState.frameIndex = (_toggleState.frameIndex + 1) % bitmaps.length;
        }, period);
      }

      // pause/resume toggle
      pauseBtn.addEventListener("click", () => {
        if (!_toggleState) {
          // nothing running â€” toggle label to Pause (no-op)
          pauseBtn.textContent = "Pause";
          return;
        }
        if (_toggleState.paused) {
          // resume
          _toggleState.paused = false;
          updateRunningFps(_toggleState.fps);
          // draw immediately to reflect resume
          _toggleState.ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
          const bmp = _toggleState.bitmaps[_toggleState.frameIndex % _toggleState.bitmaps.length];
          _toggleState.ctx.drawImage(bmp, 0, 0);
          _toggleState.frameIndex = (_toggleState.frameIndex + 1) % _toggleState.bitmaps.length;
          pauseBtn.textContent = "Pause";
        } else {
          // pause
          _toggleState.paused = true;
          if (_toggleState.timer) {
            clearInterval(_toggleState.timer);
            _toggleState.timer = null;
          }
          pauseBtn.textContent = "Resume";
        }
      });

      // slider control
      fpsSlider.addEventListener("input", (e) => {
        const v = e.target.value;
        updateFpsDisplay(v);
        updateRunningFps(Number(v));
      });

      // initialize fps UI
      updateFpsDisplay(fpsSlider.value);

      // helper to get currently filled canvases (those with content)
      function getFilledCanvases() {
        return dropZones
          .filter(z => z.canvas && z.canvas.width > 0 && z.canvas.height > 0)
          .map(z => z.canvas);
      }

      // when user clicks Align, run alignment which will start slideshow
      alignBtn.addEventListener("click", () => {
        stopToggle();
        setTimeout(() => {
          alignImages();
        }, 50);
      });

      // stop toggle when user drops a new file into any dynamic dropzone
      dropContainer.addEventListener("drop", stopToggle, true);
      dropContainer.addEventListener("change", (e) => {
        const t = e.target;
        if (t && t.matches && t.matches('input[type="file"]')) stopToggle();
      }, true);
    </script>
  </body>
</html>
