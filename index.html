<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>image-compare</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 18px;
      }
      .row {
        display: flex;
        gap: 12px;
        align-items: flex-start;
      }
      .col {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      canvas {
        border: 1px solid #999;
      }
      #matches {
        max-width: 100%;
      }
      .controls {
        margin-bottom: 12px;
        display: flex;
        gap: 12px;
        align-items: center;
      }
      label {
        font-size: 90%;
      }
      button {
        padding: 6px 10px;
      }

      /* Drag & drop styles */
      .dropzone {
        width: 150px;
        height: 100px;
        border: 2px dashed #bbb;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #666;
        background: #fafafa;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .dropzone.dragover {
        border-color: #4a90e2;
        background: #f0f8ff;
        color: #111;
      }
      .dropzone.small {
        width: 200px;
        height: 150px;
      }
      .hidden-input {
        display: none;
      }

      /* preview canvas inside dropzone */
      .dropzone canvas {
        display: block;
        max-width: 100%;
        max-height: 100%;
      }
      .drop-instruction {
        position: absolute;
        pointer-events: none;
        text-align: center;
        width: 100%;
      }

      /* slider styling */
      .fps-control {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .fps-control input[type="range"] {
        width: 150px;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <div>
        <div><strong>Images (drop here)</strong></div>
        <div id="dropContainer" class="row"></div>
      </div>

      <!-- Keep Align button -->
      <div>
        <button id="alignBtn">Align</button>
      </div>

      <!-- FPS slider + pause/resume button -->
      <div class="fps-control">
        <label for="fpsSlider">FPS:</label>
        <input id="fpsSlider" type="range" min="1" max="30" value="2" step="1" />
        <span id="fpsValue">2 fps</span>
        <button id="pauseBtn">Play</button>
      </div>

      <!-- Per-dropzone hidden inputs are created dynamically -->
    </div>

    <!-- Removed visible source/target canvases per request.
         Only the Matches/Overlay canvas remains. -->
      <div><strong>Composite</strong></div>
    <div class="row">
      <canvas id="animation" width="800" height="300"></canvas>
    </div>

    <script
      async
      src="https://docs.opencv.org/4.x/opencv.js"
      onload="onOpenCvReady();"
    ></script>

    <script>
      let srcImg = null,
        tgtImg = null;
      
      const dropContainer = document.getElementById("dropContainer");
      const dropZones = [];
      const alignBtn = document.getElementById("alignBtn");

      // FPS controls
      const fpsSlider = document.getElementById("fpsSlider");
      const fpsValue = document.getElementById("fpsValue");
      const pauseBtn = document.getElementById("pauseBtn");

      // Dynamic dropzones: create as needed and append to container
      function createDropzone() {
        const dropElem = document.createElement("div");
        dropElem.className = "dropzone";

        const instruction = document.createElement("div");
        instruction.className = "drop-instruction";
        instruction.textContent = "Drop image or click to select";
        dropElem.appendChild(instruction);

        const canvas = document.createElement("canvas");
        canvas.className = "preview-canvas";
        dropElem.appendChild(canvas);

        const inputElem = document.createElement("input");
        inputElem.type = "file";
        inputElem.accept = "image/*";
        inputElem.className = "hidden-input";
        dropElem.appendChild(inputElem);

        dropContainer.appendChild(dropElem);
        addDnDHandlers(dropElem, inputElem, canvas);
        dropZones.push({ dropElem, inputElem, canvas });
        return { dropElem, inputElem, canvas };
      }

      function allDropzonesFilled() {
        return dropZones.length > 0 && dropZones.every(z => z.dropElem.classList.contains("filled"));
      }

      function ensureExtraSlot() {
        if (allDropzonesFilled()) {
          createDropzone();
        }
      }

      const animationCanvas = document.getElementById("animation");

      // Set animation canvas size to fit viewport width while preserving aspect ratio
      function setCanvasViewportForSize(imgW, imgH) {
        const bodyMarginX = 36; // approx left+right margin from body styles
        const availW = Math.max(300, Math.floor(document.documentElement.clientWidth - bodyMarginX));
        const scale = Math.min(1, availW / imgW);
        animationCanvas.width = Math.round(imgW * scale);
        animationCanvas.height = Math.round(imgH * scale);
      }

      // Utility to prevent default drag behavior
      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }
      function addDnDHandlers(dropElem, inputElem, canvas) {
        ["dragenter", "dragover", "dragleave", "drop"].forEach((evt) =>
          dropElem.addEventListener(evt, preventDefaults, false)
        );
        ["dragenter", "dragover"].forEach((evt) =>
          dropElem.addEventListener(evt, () => dropElem.classList.add("dragover"))
        );
        ["dragleave", "drop"].forEach((evt) =>
          dropElem.addEventListener(evt, () => dropElem.classList.remove("dragover"))
        );

        dropElem.addEventListener(
          "drop",
          (e) => {
            const dt = e.dataTransfer;
            const file = dt && dt.files && dt.files[0];
            if (file) loadFileToCanvas(file, canvas, dropElem);
          },
          false
        );

        // click opens file dialog as fallback
        dropElem.addEventListener("click", () => inputElem.click());
        inputElem.addEventListener("change", () => {
          const file = inputElem.files && inputElem.files[0];
          if (file) loadFileToCanvas(file, canvas, dropElem);
          inputElem.value = ""; // reset
        });
      }
      
      // Initialize with two empty dropzones
      createDropzone();
      createDropzone();

      function loadFileToCanvas(file, canvas, dropElem, callback) {
        if (!file) return;
        const img = new Image();
        img.onload = () => {
          // Create a hidden full-resolution canvas for processing and animation
          const fullCanvas = document.createElement('canvas');
          fullCanvas.width = img.width;
          fullCanvas.height = img.height;
          const fullCtx = fullCanvas.getContext('2d');
          fullCtx.drawImage(img, 0, 0);

          // Draw a scaled preview into the visible dropzone canvas for UI
          const ctx = canvas.getContext("2d");
          const maxPreviewW = 800;
          const maxPreviewH = 600;
          canvas.width = Math.min(img.width, maxPreviewW);
          canvas.height = Math.min(img.height, maxPreviewH);
          const scale = Math.min(canvas.width / img.width, canvas.height / img.height, 1);
          const w = Math.round(img.width * scale);
          const h = Math.round(img.height * scale);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0, w, h);

          // remove instruction overlay if present
          const instr = dropElem.querySelector(".drop-instruction");
          if (instr) instr.remove();

          // mark as filled and ensure there is always an extra empty slot
          dropElem.classList.add("filled");
          ensureExtraSlot();

          // Attach full-res canvas to the corresponding dropzone entry
          const dz = dropZones.find(z => z.canvas === canvas);
          if (dz) dz.fullCanvas = fullCanvas;

          URL.revokeObjectURL(img.src);
          callback && callback();
        };
        img.onerror = () => {
          console.error("Failed to load image file.");
        };
        img.src = URL.createObjectURL(file);
      }

      function onOpenCvReady() {
        if (typeof cv === "undefined") {
          console.error("OpenCV.js script failed to load.");
          return;
        }
        if (cv.getBuildInformation !== undefined) {
          console.log("OpenCV.js ready:", cv.getBuildInformation());
        } else {
          cv['onRuntimeInitialized'] = () => {
            console.log("OpenCV.js ready:", cv.getBuildInformation());
          };
        }
      }

      function canvasToMat(canvas) {
        const ctx = canvas.getContext("2d");
        if (canvas.width === 0 || canvas.height === 0)
          return new cv.Mat(); // empty
        let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        let mat = cv.matFromImageData(imgData);
        return mat;
      }

      function matToCanvas(mat, canvas) {
        const ctx = canvas.getContext("2d");
        const img = new ImageData(
          new Uint8ClampedArray(mat.data),
          mat.cols,
          mat.rows
        );
        canvas.width = mat.cols;
        canvas.height = mat.rows;
        ctx.putImageData(img, 0, 0);
      }

      // Create a scaled copy of a canvas limited by maxDim, preserving aspect ratio.
      // Returns { canvas, scale }, where scale is the factor applied to original.
      function makeScaledCanvas(sourceCanvas, maxDim = 800) {
        const s = Math.min(maxDim / sourceCanvas.width, maxDim / sourceCanvas.height, 1);
        if (s === 1) return { canvas: sourceCanvas, scale: 1 };
        const c = document.createElement('canvas');
        c.width = Math.round(sourceCanvas.width * s);
        c.height = Math.round(sourceCanvas.height * s);
        const ctx = c.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(sourceCanvas, 0, 0, c.width, c.height);
        return { canvas: c, scale: s };
      }

      function alignImages() {
        if (typeof cv === "undefined") {
          alert("OpenCV.js not ready");
          return;
        }
        const filled = dropZones.filter(z => z.fullCanvas && z.fullCanvas.width > 0 && z.fullCanvas.height > 0);
        if (filled.length < 2) {
          alert("Load at least two images (fill two drop zones).");
          return;
        }

        // Reference is the first filled image; align all others to it
        const refCanvas = filled[0].fullCanvas;
        const others = filled.slice(1).map(z => z.fullCanvas);

        // Helper: compute warped canvas aligning srcCanvas to refCanvas
        function warpToReference(srcCanvas, refCanvas) {
          // Full-resolution mats for final warping
          let src = canvasToMat(srcCanvas);
          let ref = canvasToMat(refCanvas);
          if (src.empty() || ref.empty()) {
            src.delete && src.delete();
            ref.delete && ref.delete();
            return null;
          }
          // Downscale for feature detection/matching to improve performance
          const scaledSrc = makeScaledCanvas(srcCanvas, 800);
          const scaledRef = makeScaledCanvas(refCanvas, 800);
          let srcSmall = canvasToMat(scaledSrc.canvas);
          let refSmall = canvasToMat(scaledRef.canvas);
          let graySrc = new cv.Mat(), grayRef = new cv.Mat();
          cv.cvtColor(srcSmall, graySrc, cv.COLOR_RGBA2GRAY);
          cv.cvtColor(refSmall, grayRef, cv.COLOR_RGBA2GRAY);
          let orb = new cv.ORB();
          let kpSrc = new cv.KeyPointVector();
          let kpRef = new cv.KeyPointVector();
          let desSrc = new cv.Mat();
          let desRef = new cv.Mat();
          orb.detectAndCompute(graySrc, new cv.Mat(), kpSrc, desSrc);
          orb.detectAndCompute(grayRef, new cv.Mat(), kpRef, desRef);

          if (desSrc.rows === 0 || desRef.rows === 0) {
            [graySrc, grayRef, orb, kpSrc, kpRef, desSrc, desRef, srcSmall, refSmall, src, ref].forEach(x => x.delete && x.delete());
            return null;
          }

          let bf = new cv.BFMatcher(cv.NORM_HAMMING, false);
          let matches = new cv.DMatchVector();
          bf.match(desSrc, desRef, matches);
          const mArr = [];
          for (let i = 0; i < matches.size(); i++) mArr.push(matches.get(i));
          mArr.sort((a, b) => a.distance - b.distance);
          const keep = Math.min(200, Math.max(10, Math.floor(mArr.length * 0.3)));
          const goodMatches = new cv.DMatchVector();
          for (let i = 0; i < keep; i++) goodMatches.push_back(mArr[i]);
          if (goodMatches.size() < 4) {
            [graySrc, grayRef, orb, kpSrc, kpRef, desSrc, desRef, bf, matches, goodMatches, srcSmall, refSmall, src, ref].forEach(x => x.delete && x.delete());
            return null;
          }
          let srcPts = new cv.Mat(goodMatches.size(), 1, cv.CV_32FC2);
          let dstPts = new cv.Mat(goodMatches.size(), 1, cv.CV_32FC2);
          for (let i = 0; i < goodMatches.size(); i++) {
            const m = goodMatches.get(i);
            const pS = kpSrc.get(m.queryIdx).pt;
            const pR = kpRef.get(m.trainIdx).pt;
            srcPts.floatPtr(i, 0)[0] = pS.x;
            srcPts.floatPtr(i, 0)[1] = pS.y;
            dstPts.floatPtr(i, 0)[0] = pR.x;
            dstPts.floatPtr(i, 0)[1] = pR.y;
          }
          const mask = new cv.Mat();
          const H = cv.findHomography(srcPts, dstPts, cv.RANSAC, 5, mask);
          if (H.empty()) {
            [graySrc, grayRef, orb, kpSrc, kpRef, desSrc, desRef, bf, matches, goodMatches, srcPts, dstPts, mask, srcSmall, refSmall, src, ref].forEach(x => x.delete && x.delete());
            return null;
          }
          // Lift homography from small scale to full resolution
          const sSrc = scaledSrc.scale; // small = sSrc * full
          const sRef = scaledRef.scale; // small = sRef * full
          const h = H.data64F || H.data32F;
          const HfullArr = new Float64Array(9);
          HfullArr[0] = (1 / sRef) * h[0] * sSrc;
          HfullArr[1] = (1 / sRef) * h[1] * sSrc;
          HfullArr[2] = (1 / sRef) * h[2];
          HfullArr[3] = (1 / sRef) * h[3] * sSrc;
          HfullArr[4] = (1 / sRef) * h[4] * sSrc;
          HfullArr[5] = (1 / sRef) * h[5];
          HfullArr[6] = h[6] * sSrc;
          HfullArr[7] = h[7] * sSrc;
          HfullArr[8] = h[8];
          const Hfull = cv.matFromArray(3, 3, cv.CV_64F, HfullArr);

          // Warp full-resolution src to full-resolution ref size
          let warped = new cv.Mat();
          const dsize = new cv.Size(ref.cols, ref.rows);
          cv.warpPerspective(src, warped, Hfull, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

          // Convert to canvas
          const out = document.createElement('canvas');
          matToCanvas(warped, out);

          [graySrc, grayRef, orb, desSrc, desRef, bf, matches, srcPts, dstPts, mask, H, Hfull, srcSmall, refSmall, warped].forEach(x => x.delete && x.delete());
          kpSrc.delete();
          kpRef.delete();
          src.delete();
          ref.delete();
          goodMatches.delete();
          return out;
        }

        // Build frames: first the reference, then each warped to reference (skip nulls)
        const frames = [refCanvas];
        for (const c of others) {
          const warpedCanvas = warpToReference(c, refCanvas);
          if (warpedCanvas) frames.push(warpedCanvas);
        }

        // If only reference, nothing to animate
        if (frames.length < 2) {
          const ctx = animationCanvas.getContext('2d');
          setCanvasViewportForSize(refCanvas.width, refCanvas.height);
          ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
          ctx.drawImage(refCanvas, 0, 0);
          return;
        }

        // Start slideshow across all frames
        startSlideshowFromCanvases(frames, Number(fpsSlider.value)).catch(e => console.error(e));
      }

      alignBtn.addEventListener("click", alignImages);

      // Toggle state object used to manage animation interval/bitmaps/fps/pause
      let _toggleState = null;
      function stopToggle() {
        if (!_toggleState) return;
        try {
          if (_toggleState.timer) clearInterval(_toggleState.timer);
          if (_toggleState.bitmaps)
            _toggleState.bitmaps.forEach((b) => b && b.close());
        } catch (e) {
          console.error("Error stopping toggle:", e);
        }
        _toggleState = null;
        pauseBtn.textContent = "Pause";
      }

      async function startSlideshowFromCanvases(canvases, fps = 2) {
        stopToggle();
        try {
          const bitmaps = await Promise.all(canvases.map(c => createImageBitmap(c)));
          const ctx = animationCanvas.getContext("2d");
          const maxW = Math.max(...bitmaps.map(b => b.width));
          const maxH = Math.max(...bitmaps.map(b => b.height));
          setCanvasViewportForSize(maxW, maxH);

          // initialize toggle state
          _toggleState = {
            bitmaps,
            ctx,
            fps: Math.max(1, Math.floor(fps)),
            paused: false,
            frameIndex: 0,
            timer: null,
            view: { scale: 1, tx: 0, ty: 0 },
          };

          function drawCurrentFrame(advance = false) {
            if (!_toggleState) return;
            const { bitmaps, view } = _toggleState;
            if (!bitmaps || bitmaps.length === 0) return;
            const bmp = bitmaps[_toggleState.frameIndex % bitmaps.length];
            const ctxLocal = _toggleState.ctx;
            ctxLocal.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
            ctxLocal.save();
            ctxLocal.setTransform(view.scale, 0, 0, view.scale, view.tx, view.ty);
            // Disable smoothing to keep native pixel detail when zooming in
            ctxLocal.imageSmoothingEnabled = false;
            ctxLocal.drawImage(bmp, 0, 0);
            ctxLocal.restore();
            if (advance) {
              _toggleState.frameIndex = (_toggleState.frameIndex + 1) % bitmaps.length;
            }
          }

          _toggleState.drawCurrent = (advance = false) => drawCurrentFrame(advance);

          function setTimer() {
            if (!_toggleState) return;
            if (_toggleState.timer) clearInterval(_toggleState.timer);
            const period = 1000 / Math.max(1, _toggleState.fps);
            _toggleState.timer = setInterval(() => {
              _toggleState.drawCurrent(true);
            }, period);
          }

          // draw initial frame and start interval
          _toggleState.drawCurrent(true);
          setTimer();

          // Adjust viewport on window resize and keep view scale within min
          const onResize = () => {
            if (!_toggleState) return;
            setCanvasViewportForSize(maxW, maxH);
            const bitmapsLocal = _toggleState.bitmaps;
            const bmp = bitmapsLocal[_toggleState.frameIndex % bitmapsLocal.length];
            const minScale = Math.min(animationCanvas.width / bmp.width, animationCanvas.height / bmp.height);
            if (_toggleState.view) {
              _toggleState.view.scale = Math.max(_toggleState.view.scale, minScale);
            }
            _toggleState.drawCurrent(false);
          };
          window.addEventListener('resize', onResize);
        } catch (e) {
          console.error("Failed to start toggle:", e);
        }
      }

      // update fps display and, if running, update the running timer
      function updateFpsDisplay(val) {
        fpsValue.textContent = val + " fps";
      }

      function updateRunningFps(newFps) {
        if (!_toggleState) return;
        _toggleState.fps = Math.max(1, Math.floor(newFps));
        if (_toggleState.paused) return;
        // recreate interval preserving state
        if (_toggleState.timer) clearInterval(_toggleState.timer);
        const period = 1000 / _toggleState.fps;
        _toggleState.timer = setInterval(() => {
          if (!_toggleState) return;
          _toggleState.drawCurrent(true);
        }, period);
      }

      // pause/resume toggle
      pauseBtn.addEventListener("click", () => {
        if (!_toggleState) {
          // nothing running â€” toggle label to Pause (no-op)
          pauseBtn.textContent = "Pause";
          return;
        }
        if (_toggleState.paused) {
          // resume
          _toggleState.paused = false;
          updateRunningFps(_toggleState.fps);
          // draw immediately to reflect resume
          _toggleState.drawCurrent(true);
          pauseBtn.textContent = "Pause";
        } else {
          // pause
          _toggleState.paused = true;
          if (_toggleState.timer) {
            clearInterval(_toggleState.timer);
            _toggleState.timer = null;
          }
          pauseBtn.textContent = "Resume";
        }
      });

      // slider control
      fpsSlider.addEventListener("input", (e) => {
        const v = e.target.value;
        updateFpsDisplay(v);
        updateRunningFps(Number(v));
      });

      // initialize fps UI
      updateFpsDisplay(fpsSlider.value);

      // helper to get currently filled canvases (those with content)
      function getFilledCanvases() {
        return dropZones
          .filter(z => z.canvas && z.canvas.width > 0 && z.canvas.height > 0)
          .map(z => z.canvas);
      }

      // when user clicks Align, run alignment which will start slideshow
      alignBtn.addEventListener("click", () => {
        stopToggle();
        setTimeout(() => {
          alignImages();
        }, 50);
      });

      // stop toggle when user drops a new file into any dynamic dropzone
      dropContainer.addEventListener("drop", stopToggle, true);
      dropContainer.addEventListener("change", (e) => {
        const t = e.target;
        if (t && t.matches && t.matches('input[type="file"]')) stopToggle();
      }, true);

      // Zoom & Pan interactions for Composite canvas
      (function enableZoomPan() {
        let isPanning = false;
        let lastX = 0, lastY = 0;
        const maxScale = 10;

        function getView() {
          if (!_toggleState) return null;
          if (!_toggleState.view) _toggleState.view = { scale: 1, tx: 0, ty: 0 };
          return _toggleState.view;
        }

        function computeMinScale() {
          if (!_toggleState || !_toggleState.bitmaps || _toggleState.bitmaps.length === 0) return 0.1;
          const idx = _toggleState.frameIndex % _toggleState.bitmaps.length;
          const bmp = _toggleState.bitmaps[idx];
          if (!bmp) return 0.1;
          const scaleX = animationCanvas.width / bmp.width;
          const scaleY = animationCanvas.height / bmp.height;
          // Fit-to-canvas minimum: don't allow zooming out smaller than fit
          return Math.min(scaleX, scaleY);
        }

        animationCanvas.addEventListener('wheel', (e) => {
          // Zoom around mouse position
          const view = getView();
          if (!view) return;
          e.preventDefault();
          const rect = animationCanvas.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;

          const scaleFactor = e.deltaY < 0 ? 1.1 : 0.9;
          const prevScale = view.scale;
          let newScale = prevScale * scaleFactor;
          const minScale = computeMinScale();
          newScale = Math.min(maxScale, Math.max(minScale, newScale));
          if (newScale === prevScale) return;

          const imgX = (mx - view.tx) / prevScale;
          const imgY = (my - view.ty) / prevScale;
          view.scale = newScale;
          view.tx = mx - imgX * newScale;
          view.ty = my - imgY * newScale;

          if (_toggleState && _toggleState.drawCurrent) {
            _toggleState.drawCurrent(false);
          } else {
            const ctx = animationCanvas.getContext('2d');
            ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
          }
        }, { passive: false });

        animationCanvas.addEventListener('mousedown', (e) => {
          const view = getView();
          if (!view) return;
          isPanning = true;
          lastX = e.clientX;
          lastY = e.clientY;
        });

        window.addEventListener('mousemove', (e) => {
          if (!isPanning) return;
          const view = getView();
          if (!view) return;
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          lastX = e.clientX;
          lastY = e.clientY;
          view.tx += dx;
          view.ty += dy;
          if (_toggleState && _toggleState.drawCurrent) {
            _toggleState.drawCurrent(false);
          }
        });

        window.addEventListener('mouseup', () => { isPanning = false; });
        animationCanvas.addEventListener('mouseleave', () => { isPanning = false; });

        // Double-click to reset view
        animationCanvas.addEventListener('dblclick', () => {
          const view = getView();
          if (!view) return;
          const minScale = computeMinScale();
          view.scale = minScale;
          view.tx = 0;
          view.ty = 0;
          if (_toggleState && _toggleState.drawCurrent) {
            _toggleState.drawCurrent(false);
          }
        });
      })();
    </script>
  </body>
</html>
